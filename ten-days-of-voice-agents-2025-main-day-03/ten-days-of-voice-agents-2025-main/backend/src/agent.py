import json
import logging
import traceback
import time
from datetime import datetime
from pathlib import Path
from dotenv import load_dotenv
from typing import Annotated, List
from livekit.agents import (
    Agent,
    AgentSession,
    JobContext,
    JobProcess,
    MetricsCollectedEvent,
    RoomInputOptions,
    WorkerOptions,
    cli,
    metrics,
    tokenize,
    function_tool,
    RunContext,
)
from livekit.plugins import murf, silero, google, deepgram, noise_cancellation
from livekit.plugins.turn_detector.multilingual import MultilingualModel

logger = logging.getLogger("agent")

env_path = Path(__file__).parent.parent / ".env.local"
load_dotenv(dotenv_path=env_path)


class Assistant(Agent):
    def __init__(self) -> None:
        # Load history to inject into context
        history_context = self._get_history_context()
        
        super().__init__(
            instructions=f"""You are a supportive, grounded Health & Wellness Voice Companion.
            
            **YOUR GOAL:**
            Conduct a short daily check-in with the user about their mood and goals. Be warm, empathetic, but realistic.
            
            **CONTEXT FROM PREVIOUS SESSIONS:**
            {history_context}
            
            **INTERACTION FLOW:**
            1.  **Greet & Check-in**: Ask how they are feeling today and what their energy is like. Reference past context if relevant (e.g., "Last time we talked, you mentioned being low on energy. How does today compare?").
            2.  **Intentions**: Ask for 1-3 simple, practical goals for the day.
            3.  **Support**: Offer *brief*, grounded advice (e.g., "Take a 5-minute break," "Drink water"). DO NOT give medical advice.
            4.  **Recap & Save**: Summarize what they said (mood + goals). Then, explicitly ask: "Does this sound right?"
            5.  **Persist**: Once the user confirms with "yes" or similar, call the `save_checkin` tool to save the entry.
            6.  **Goodbye**: Wish them well and end the conversation.
            
            **GUIDELINES:**
            -   Keep it short and conversational.
            -   Avoid toxic positivity; be real.
            -   If the user reports serious distress, suggest professional help gently, but do not diagnose.
            """,
        )

    def _get_history_context(self) -> str:
        """Reads the wellness_log.json and returns a summary of the last session."""
        try:
            # wellness_log.json is in the project root
            log_path = Path(__file__).resolve().parent.parent.parent / "wellness_log.json"
            
            if not log_path.exists():
                return "No previous check-ins found. This is the first session."
            
            with open(log_path, "r") as f:
                data = json.load(f)
                
            if not data:
                return "No previous check-ins found."
                
            # Get the most recent entry
            last_entry = data[-1]
            return f"""
            Last Check-in ({last_entry.get('date', 'Unknown Date')}):
            - Mood: {last_entry.get('mood', 'Unknown')}
            - Goals: {', '.join(last_entry.get('goals', []))}
            - Summary: {last_entry.get('summary', '')}
            """
        except Exception as e:
            logger.error(f"Error reading history: {e}")
            return "Error retrieving past history."

    @function_tool
    async def save_checkin(
        self,
        ctx: RunContext,
        mood: str,
        goals: List[str],
        summary: str,
    ):
        """Save the daily wellness check-in results.
        
        Use this tool AFTER the user has confirmed the recap of their mood and goals.
        
        Args:
            mood: The user's self-reported mood or energy level.
            goals: A list of 1-3 objectives the user mentioned.
            summary: A brief, one-sentence summary of the user's state generated by you.
        """
        logger.info(f"Saving check-in: Mood={mood}, Goals={goals}")
        
        entry = {
            "timestamp": int(time.time()),
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "mood": mood,
            "goals": goals,
            "summary": summary
        }
        
        try:
            log_path = Path(__file__).resolve().parent.parent.parent / "wellness_log.json"
            
            data = []
            if log_path.exists():
                with open(log_path, "r") as f:
                    try:
                        data = json.load(f)
                    except json.JSONDecodeError:
                        data = []
            
            data.append(entry)
            
            with open(log_path, "w") as f:
                json.dump(data, f, indent=2)
                
            return "Check-in saved successfully. I'll remember this for next time!"
            
        except Exception as e:
            logger.error(f"Failed to save check-in: {e}")
            return f"I had a little trouble writing to my journal, but I've noted it down. (Error: {e})"


def prewarm(proc: JobProcess):
    proc.userdata["vad"] = silero.VAD.load()


async def entrypoint(ctx: JobContext):
    try:
        ctx.log_context_fields = {
            "room": ctx.room.name,
        }

        session = AgentSession(
            stt=deepgram.STT(model="nova-3"),
            llm=google.LLM(
                model="gemini-2.5-flash",
            ),
            tts=murf.TTS(
                    voice="en-US-matthew",
                    style="Conversation",
                    tokenizer=tokenize.basic.SentenceTokenizer(min_sentence_len=1),
                ),
            turn_detection=MultilingualModel(),
            vad=ctx.proc.userdata["vad"],
            preemptive_generation=True,
        )

        usage_collector = metrics.UsageCollector()

        @session.on("metrics_collected")
        def _on_metrics_collected(ev: MetricsCollectedEvent):
            metrics.log_metrics(ev.metrics)
            usage_collector.collect(ev.metrics)

        async def log_usage():
            summary = usage_collector.get_summary()
            logger.info(f"Usage: {summary}")

        ctx.add_shutdown_callback(log_usage)

        await session.start(
            agent=Assistant(),
            room=ctx.room,
            room_input_options=RoomInputOptions(
                noise_cancellation=noise_cancellation.BVC(),
            ),
        )

        await ctx.connect()
    
    except Exception as e:
        logger.error(f"Error in entrypoint: {e}")
        logger.error(traceback.format_exc())
        raise e


if __name__ == "__main__":
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))
